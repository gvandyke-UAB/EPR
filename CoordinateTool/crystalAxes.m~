classdef crystalAxes
    % crystalAxes stores axes data subject to rotations
      
    
    properties
        aAxisInitial {mustBeNumeric}
        bAxisInitial {mustBeNumeric}
        cAxisInitial {mustBeNumeric}
        aAxisFinal {mustBeNumeric}
        bAxisFinal {mustBeNumeric}
        cAxisFinal {mustBeNumeric}
        completeRotationMatrix = [1,0,0;0,1,0;0,0,1]; % starts as identity matrix
    end
    
    methods
        function obj = crystalAxes(aVector,bVector,cVector)
            % Construct an instance of this class
            % Constructs by assigning axes
            % User specifies row vectors to represent the three crystal axes
            
            obj.aAxisInitial = aVector; 
            obj.bAxisInitial = bVector;
            obj.cAxisInitial = cVector;
        end
        
        function adjustedAxes = adjustAxes(obj,axis,labAxis,angle)
            % Rotates a specified axis by angle (in degrees) about labAxis
            if strcmp(labAxis,'xL')
                rotationMatrix = rotz(angle);
                if strcmp(axis,'b')
                    obj.bAxisInitial = (rotationMatrix*obj.bAxisInitial.').';                   
                elseif strcmp(axis,'c')
                    obj.cAxisInitial = (rotationMatrix*obj.cAxisInitial.').';                   
                end
            elseif strcmp(labAxis,'yL')
                rotationMatrix = rotx(angle);
                if strcmp(axis,'a')
                    obj.aAxisInitial = (rotationMatrix*obj.aAxisInitial.').';
                elseif strcmp(axis,'c')
                    obj.cAxisInitial = (rotationMatrix*obj.cAxisInitial.').';                   
                end
            elseif strcmp(labAxis,'zL')
                rotationMatrix = roty(angle);
                if strcmp(axis,'a')
                    obj.aAxisInitial = (rotationMatrix*obj.aAxisInitial.').';                  
                elseif strcmp(axis,'b')
                    obj.bAxisInitial = (rotationMatrix*obj.bAxisInitial.').';
                end
            end
           adjustedAxes = obj; 
        end
        
        function rotatedAxes = rotateAxes(obj,labAxis,angle)
            % rotates all 3 axes about labAxis by angle
            if strcmp(labAxis,'xL')
                rotationMatrix = rotz(angle);
                obj.aAxisFinal = (rotationMatrix*obj.aAxis.').';
                obj.bAxisFinal = (rotationMatrix*obj.bAxis.').';
                obj.cAxisFinal = (rotationMatrix*obj.cAxis.').';
            elseif strcmp(labAxis,'yL')
                rotationMatrix = rotx(angle);
                obj.aAxisFinal = (rotationMatrix*obj.aAxis.').';
                obj.bAxisFinal = (rotationMatrix*obj.bAxis.').';
                obj.cAxisFinal = (rotationMatrix*obj.cAxis.').';
            elseif strcmp(labAxis,'zL')
                rotationMatrix = roty(angle);
                obj.aAxisFinal = (rotationMatrix*obj.aAxis.').';
                obj.bAxisFinal = (rotationMatrix*obj.bAxis.').';
                obj.cAxisFinal = (rotationMatrix*obj.cAxis.').';
            end
            obj.completeRotationMatrix = rotationMatrix * obj.completeRotationMatrix;
            rotatedAxes = obj;
        end
        
        function showAxesFigure(obj)
            % this function is written purely beause quiver3 is ridiculous
            % and needs some preprocessing 
            
            close
            
            xCoordinates = [obj.aAxis(1) obj.bAxis(1) obj.cAxis(1)];
            yCoordinates = [obj.aAxis(2) obj.bAxis(2) obj.cAxis(2)];
            zCoordinates = [obj.aAxis(3) obj.bAxis(3) obj.cAxis(3)];
            
            figure('NumberTitle', 'off', 'Name', 'Crystal Axes Euler Angle Tool');
            quiver3([0,0,0],[0,0,0],[0,0,0],xCoordinates,yCoordinates,zCoordinates,'LineWidth',1);
            xlabel('yL');ylabel('zL'),zlabel('xL');
            
            text(obj.aAxis(1),obj.aAxis(2),obj.aAxis(3),'a-axis');
            text(obj.bAxis(1),obj.bAxis(2),obj.bAxis(3),'b-axis');
            text(obj.cAxis(1),obj.cAxis(2),obj.cAxis(3),'c-axis');
            
            
        end
            
    end
end

